///usr/bin/true; exec /usr/bin/env go run "$0" "$@"
// Mostly generated by GPT-4
package main

import (
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"os/user"
	"strings"
)

func sanitizeFilename(filename string) string {
	filename = strings.Replace(filename, "/", "_", -1)
	usr, _ := user.Current()
	dir := usr.HomeDir + "/Public/"

	path := dir + filename

	return path
}

func uploadFile(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		w.Write([]byte(`
			   <html><head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
			   <body>
			   <form action="/" method="POST" enctype="multipart/form-data">
			   <input type="file" name="file" />
			   <input type="submit" value="Upload" />
			   </form>
			   </body></html>`))
	case "POST":
		// Parse the multipart form
		if err := r.ParseMultipartForm(10 << 20); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		file, header, err := r.FormFile("file")
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		sanitized_path := sanitizeFilename(header.Filename)

		out, err := os.Create(sanitized_path)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		defer out.Close()

		_, err = io.Copy(out, file)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		fmt.Fprintf(w, "File uploaded successfully: "+sanitized_path)
		fmt.Printf("%s\n", sanitized_path)
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
	}
}

var PORT = 8080

func getHTTPURL(addr net.Addr) (string, error) {
	// Assuming addr is net.IPNet
	ipnet, ok := addr.(*net.IPNet)
	if !ok {
		return "", fmt.Errorf("Cannot get IPNet from %s", addr.String())
	}

	ip := ipnet.IP
	if ip4 := ip.To4(); ip4 != nil {
		return fmt.Sprintf("http://%s:%d", ip4, PORT), nil
	} else {
		// filter out ipv6 link-local address
		if ip.IsLinkLocalUnicast() {
			return "", fmt.Errorf("Link-local address %s is ignored", ip.String())
		}
		return fmt.Sprintf("http://[%s]:%d", ip, PORT), nil
	}
}

func showStartedMsg() error {
	ifaces, err := net.Interfaces()
	if err != nil {
		return err
	}
	fmt.Println("Server will start at:")
	for _, i := range ifaces {
		addrs, err := i.Addrs()
		if err != nil {
			fmt.Print(fmt.Errorf("Error: %s\n", err.Error()))
			continue
		}
		iName := i.Name
		for _, addr := range addrs {
			urlStr, err := getHTTPURL(addr)
			if err != nil {
				continue
			}
			fmt.Printf("%s %s\n", iName, urlStr)
		}
	}
	return nil
}

func main() {
	http.HandleFunc("/", uploadFile)

	if showStartedMsg() != nil {
		fmt.Println("Cannot get interface address. Try to start server at 8080 manually.")
	}
	http.ListenAndServe(":8080", nil)
}
