///usr/bin/true; exec /usr/bin/env go run "$0" "$@"
// Mostly generated by GPT-4
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"os/user"
	"strings"
)

func sanitize_filename(filename string) string {
	filename = strings.Replace(filename, "/", "_", -1)
	usr, _ := user.Current()
	dir := usr.HomeDir + "/Public/"

	path := dir + filename

	return path
}

func uploadFile(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		w.Write([]byte(`
			   <html><head><meta name="viewport" content="width=device-width, initial-scale=1" /></head>
			   <body>
			   <form action="/" method="POST" enctype="multipart/form-data">
			   <input type="file" name="file" />
			   <input type="submit" value="Upload" />
			   </form>
			   </body></html>`))
	case "POST":
		// Parse the multipart form
		if err := r.ParseMultipartForm(10 << 20); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		file, header, err := r.FormFile("file")
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		sanitized_path := sanitize_filename(header.Filename)

		out, err := os.Create(sanitized_path)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		defer out.Close()

		_, err = io.Copy(out, file)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		fmt.Fprintf(w, "File uploaded successfully: "+sanitized_path)
		fmt.Printf("%s\n", sanitized_path)
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
	}
}

func main() {
	http.HandleFunc("/", uploadFile)

	fmt.Printf("Server started at :8080\n")
	http.ListenAndServe(":8080", nil)
}
